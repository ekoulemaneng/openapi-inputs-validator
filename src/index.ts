import fs from 'fs'
import path from 'path'
import yaml from 'yaml'
import { Format, KeywordDefinition } from 'ajv'
import { addNewFormats, addKeywords } from './ajv'
import { OpenAPIv31x, OpenAPIv30x } from 'openapi-objects-types'
import { AjvValidatorsIndex, ajvValidatorsGenerator } from './validators'
import HTTPStatusCode from 'openapi-objects-types/types/common/http-status-code'
import { Resolver } from '@stoplight/json-ref-resolver'
import { IResolveError } from '@stoplight/json-ref-resolver/types'

type Operation = 'get' | 'put' | 'post' | 'delete' | 'options' | 'head' | 'patch' | 'trace'

type RequestInputs = {
    path?: Record<string, any>
    header?: Record<string, any>
    cookie?: Record<string, any>
    query?: Record<string, any>
    body?: any
}

type ResponsesInputs = {
    statusCode: Exclude<HTTPStatusCode, '1xx' | '2xx' | '3xx' | '4xx' | '5xx' | 'default'>
    headers: Record<string, any>
    content: any
}

type Options = { 
    type: 'request' | 'response' | 'both'
    formats?: Record<string, Format>
    keywords?: Array<string | KeywordDefinition> 
}

const getSpec = async (spec: OpenAPIv31x.OpenAPI | OpenAPIv30x.OpenAPI | string) => {
    if (!spec) throw new Error
    let schema: OpenAPIv31x.OpenAPI | OpenAPIv30x.OpenAPI
    if (!['string', 'object'].includes(typeof spec)) throw new Error
    else if (typeof spec === 'object') schema = spec
    else {
        const filePath = path.resolve(__dirname, spec)
        const data = await fs.promises.readFile(filePath, 'utf8')
        const ext = path.extname(filePath).toLowerCase()
        if (['.yaml', '.yml'].includes(ext)) schema = yaml.parse(data)
        else if (ext === '.json') schema = JSON.parse(data)
        else throw new Error
    }
    return schema
}

/**
 * AJV validators generator from an OpenAPI specification
 * @param spec Object or file (json or yaml) containing the OpenAPI specification. Mandatory.
 * @param options Settings for validators generating. Optional. An object with the following keys: type ('resquest', 'responses' or 'both), formats (new formats) and keywords (new keywords).
 * @returns List of ajv validators
 */
const compile = async (spec: OpenAPIv31x.OpenAPI | OpenAPIv30x.OpenAPI | string, options: Options = { type: 'request' }) => {
    if (!spec) throw new Error
    if (options?.formats) addNewFormats(options.formats)
    if (options?.keywords) addKeywords(options.keywords)
    const schema = await getSpec(spec)
    const resolver = new Resolver()
    const schemaResolved = await resolver.resolve(schema)
    if (schemaResolved && schemaResolved.errors.length > 0) {
        const errors: Array<IResolveError> = []
        schemaResolved.errors.forEach(error => errors.push(error))
        throw new Error(JSON.stringify(errors))
    }
    let validators: Array<AjvValidatorsIndex> = await ajvValidatorsGenerator(schemaResolved.result, options.type)
    return validators
}

/**
 * Request validation in accordance with the OpenAPI specification provided
 * @param path String that specifies an OpenAPI path. Mandatory.
 * @param operation String that specifies an http operation (get, post, put, delete, patch, options, trace, head). Mandatory.
 * @param inputs Object with optional keys: path (object), header (object), cookies (object), query (object) and body (any). Mandatory.
 * @param validators List of ajv validators generated by @compile function. Mandatory.
 * @returns Boolean value indicating whether inputs is valid accordance with the OpenAPI specification. If false, an abject.
 */
const validateRequest = (path: string, operation: Operation, inputs: RequestInputs, validators: Array<AjvValidatorsIndex>) => {
    if (!path) throw new Error
    if (typeof path !== 'string') throw new Error
    if (!operation) throw new Error
    if (['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace'].includes(operation.toLowerCase())) throw new Error
    if (!inputs) throw new Error
    if (typeof inputs !== 'object') throw new Error
    if (Object.keys(inputs).some(key => !['path', 'header', 'cookie', 'query', 'body'].includes(key))) throw new Error
    if (!validators) throw new Error
    if (validators.length === 0) throw new Error
    const validator = validators.find(validator => validator.type === 'request' && validator.path === path && validator.operation === operation.toLowerCase())
    if (!validator) throw new Error
    const validate = validator.validator
    if (!validate) throw new Error
    const result = validate(inputs)
    if (typeof result === 'boolean' && result === true) return result
    return { errors: validate.errors }
}

/**
 * Responses validation in accordance with the OpenAPI specification provided
 * @param path String that specifies an OpenAPI path. Mandatory.
 * @param operation String that specifies an http operation (get, post, put, delete, patch, options, trace, head). Mandatory.
 * @param inputs Object with optional keys: path (object), header (object), cookies (object), query (object) and body (any). Mandatory.
 * @param validators List of ajv validators generated by @compile function. Mandatory.
 * @returns Boolean value indicating whether inputs is valid accordance with the OpenAPI specification. If false, an abject.
 */
const validateResponse = (path: string, operation: Operation, inputs: ResponsesInputs, validators: Array<AjvValidatorsIndex>) => {
    if (!path) throw new Error
    if (typeof path !== 'string') throw new Error
    if (!operation) throw new Error
    if (['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace'].includes(operation.toLowerCase())) throw new Error
    if (!inputs) throw new Error
    if (typeof inputs !== 'object') throw new Error
    if (Object.keys(inputs).some(key => !['path', 'header', 'cookie', 'query', 'body'].includes(key))) throw new Error
    if (!validators) throw new Error
    const validator = validators.find(validator => validator.type === 'response' && validator.path === path && validator.operation === operation.toLowerCase())
    if (!validator) throw new Error
    if (validators.length === 0) throw new Error
    const validate = validator.validator
    if (!validate) throw new Error
    const result = validate(inputs)
    if (typeof result === 'boolean' && result === true) return result
    return { errors: validate.errors }
}

export { compile, validateRequest, validateResponse }